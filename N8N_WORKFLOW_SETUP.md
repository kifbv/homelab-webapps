# n8n Workflow Setup Guide

This guide explains how to import and configure the "New Webapp Creation" workflow in n8n.

## Prerequisites

### 1. API Credentials

You need to configure credentials in n8n for:

- **OpenAI API** - For ChatGPT architecture design
- **Anthropic API** - For Claude code generation

### 2. n8n Pod Requirements

The n8n deployment must have:

‚úÖ Git configured with SSH keys (already done)
‚úÖ ServiceAccount with RBAC permissions to create Jobs (already done)
‚úÖ Access to filesystem at `/home/node/.n8n/repos/` (already done via PVC)
‚ùå **kubectl NOT required** (we use Kubernetes API directly via HTTP Request)

## Workflow Import

### Step 1: Import Workflow

1. Open n8n web interface: `https://n8n.k8s-lab.dev`
2. Go to **Workflows** ‚Üí **Add Workflow** ‚Üí **Import from File**
3. Select the file: `n8n-workflow-new-webapp.json`
4. Click **Import**

### Step 2: Configure Credentials

After import, you'll see warnings about missing credentials. Configure them:

#### OpenAI Credentials

1. Click on the **ChatGPT Architecture Design** node
2. Click **Select Credential** ‚Üí **+ Create New**
3. Name: `OpenAI Account`
4. Enter your OpenAI API key
5. Save

#### Anthropic Credentials

1. Click on the **Claude Code Generation** node
2. For Anthropic, you may need to use the Chat Model node differently
3. **Alternative**: Use the generic OpenAI node with Anthropic-compatible endpoint

**Important Note**: The workflow currently uses `@n8n/n8n-nodes-langchain.lmChatAnthropic` which requires Anthropic credentials. If you don't have this node available, you can:

- Replace with OpenAI node using Claude models via OpenRouter
- Or use only OpenAI for both architecture and code generation

### Step 3: Test the Workflow

1. Click **Test workflow** button
2. Open the Chat interface (click the chat icon)
3. Type: "I want to build a simple kanban board application"
4. Press Send
5. Watch the workflow execute

## Workflow Overview

The workflow follows this flow:

```
1. Chat Trigger (user input)
   ‚Üì
2. Prepare ChatGPT Prompt
   ‚Üì
3. ChatGPT Architecture Design (parallel with Git clones)
   ‚Üì
4. Prepare Claude Prompt
   ‚Üì
5. Claude Code Generation
   ‚Üì
6. Write Files to Disk
   ‚Üì
7. npm install (generate package-lock.json)
   ‚Üì
8. Git Add ‚Üí Commit ‚Üí Push (homelab-webapps repo)
   ‚Üì
9. Generate BuildKit Job YAML
   ‚Üì
10. Get K8s ServiceAccount Token
   ‚Üì
11. Create BuildKit Job (HTTP Request to K8s API)
   ‚Üì
12. Wait Loop (check job status every 5 seconds)
   ‚Üì
13. Generate Kubernetes Manifests
   ‚Üì
14. Write Manifests to Disk
   ‚Üì
15. Git Add ‚Üí Commit ‚Üí Push (homelab repo)
   ‚Üì
16. Respond to Chat (success message)
```

## Important Configuration Details

### Kubernetes API Authentication

The workflow uses the ServiceAccount token automatically mounted at:
```
/var/run/secrets/kubernetes.io/serviceaccount/token
```

The **Get K8s Token** node reads this token and uses it for all Kubernetes API calls.

### HTTP Request to Kubernetes API

Instead of `kubectl`, we use HTTP Request nodes to interact with Kubernetes:

**Create Job:**
- Method: POST
- URL: `https://kubernetes.default.svc.cluster.local/apis/batch/v1/namespaces/build-system/jobs`
- Headers:
  - `Authorization: Bearer <token>`
  - `Content-Type: application/yaml`
- Body: BuildKit Job YAML

**Check Job Status:**
- Method: GET
- URL: `https://kubernetes.default.svc.cluster.local/apis/batch/v1/namespaces/build-system/jobs/<job-name>`
- Headers: `Authorization: Bearer <token>`

**Important**: The HTTP Request node must have `allowUnauthorizedCerts: true` in options because we're using self-signed certificates for the Kubernetes API.

### File System Operations

The workflow writes files to `/home/node/.n8n/repos/`:

```
/home/node/.n8n/repos/
‚îú‚îÄ‚îÄ homelab-webapps/          # Cloned from GitHub
‚îÇ   ‚îî‚îÄ‚îÄ <webapp-name>/        # Generated by workflow
‚îÇ       ‚îú‚îÄ‚îÄ Dockerfile
‚îÇ       ‚îú‚îÄ‚îÄ package.json
‚îÇ       ‚îú‚îÄ‚îÄ package-lock.json
‚îÇ       ‚îî‚îÄ‚îÄ src/
‚îÇ           ‚îî‚îÄ‚îÄ index.js
‚îî‚îÄ‚îÄ homelab/                  # Cloned from GitHub
    ‚îî‚îÄ‚îÄ kubernetes/
        ‚îî‚îÄ‚îÄ rpi-cluster/
            ‚îî‚îÄ‚îÄ apps/
                ‚îî‚îÄ‚îÄ <webapp-name>/
                    ‚îú‚îÄ‚îÄ ks.yaml
                    ‚îî‚îÄ‚îÄ app/
                        ‚îú‚îÄ‚îÄ deployment.yaml
                        ‚îú‚îÄ‚îÄ service.yaml
                        ‚îú‚îÄ‚îÄ httproute.yaml
                        ‚îú‚îÄ‚îÄ imagerepository.yaml
                        ‚îú‚îÄ‚îÄ imagepolicy.yaml
                        ‚îî‚îÄ‚îÄ kustomization.yaml
```

### Wait Loop Pattern

The workflow implements a polling pattern to wait for BuildKit Job completion:

1. **Wait 5 seconds** node waits for 5 seconds
2. **Check Job Status** queries Kubernetes API
3. **Job Complete?** If node checks `status.succeeded === 1`
   - If true: Continue to manifest generation
   - If false: **Loop Back** node routes back to Wait node

This loop continues until the build succeeds (or you manually stop it if it fails).

## Troubleshooting

### Issue 1: "kubectl not found"

**Solution**: This workflow doesn't use kubectl! It uses HTTP Request to call Kubernetes API directly. Make sure the HTTP Request nodes are configured correctly.

### Issue 2: Git operations fail

**Check**:
1. SSH keys are mounted: `kubectl -n automation exec deployment/n8n -- ls -la /home/node/.ssh/`
2. Git config exists: `kubectl -n automation exec deployment/n8n -- cat /home/node/.gitconfig`
3. Repositories can be accessed: `kubectl -n automation exec deployment/n8n -- git ls-remote git@github.com-webapps:kifbv/homelab-webapps.git`

### Issue 3: Kubernetes API calls return 401 Unauthorized

**Check**:
1. ServiceAccount token exists: `kubectl -n automation exec deployment/n8n -- cat /var/run/secrets/kubernetes.io/serviceaccount/token`
2. RBAC permissions are correct: `kubectl -n build-system get rolebinding n8n-build-manager -o yaml`

### Issue 4: File writes fail

**Check**:
1. PVC is mounted: `kubectl -n automation exec deployment/n8n -- df -h /home/node/.n8n`
2. Permissions: `kubectl -n automation exec deployment/n8n -- ls -ld /home/node/.n8n`

### Issue 5: AI nodes return errors

**Check**:
1. API credentials are correctly configured
2. API quotas/limits not exceeded
3. Prompt is not too long

### Issue 6: Build never completes

The Wait loop will run indefinitely if the build fails. To debug:

1. Check BuildKit Job status: `kubectl -n build-system get jobs`
2. Get Job logs: `kubectl -n build-system logs job/<job-name>`
3. Check for errors in logs

**Improvement**: Add a timeout or max iterations to the loop (future enhancement).

## Customization

### Change AI Models

#### Use Different ChatGPT Model

Edit the **ChatGPT Architecture Design** node:
- Change `modelId` from `gpt-4o` to `gpt-4o-mini` (cheaper) or `gpt-4-turbo`

#### Use Only OpenAI (Remove Claude)

1. Delete the **Claude Code Generation** node
2. Modify **Prepare Claude Prompt** to send to OpenAI instead
3. Use `gpt-4o` for code generation (it's quite good!)

### Adjust Build Timeout

Currently waits indefinitely. To add timeout:

1. Add a **Set** node before the wait loop to initialize a counter
2. Increment counter in **Loop Back** node
3. Add condition in **Job Complete?** to check counter > max (e.g., 120 = 10 minutes)

### Change Default Image Registry

Edit the **Generate BuildKit Job** node:
- Change `registry.k8s-lab.dev` to your registry URL

### Modify AI Prompts

The prompts are in Code nodes:

- **Prepare ChatGPT Prompt**: Architecture design instructions
- **Prepare Claude Prompt**: Code generation instructions

Edit these to customize output format, add constraints, or change requirements.

## Testing Scenarios

### Test 1: Simple Express App

Input: "I want to build a simple todo list API"

Expected:
- ChatGPT designs an Express.js API with database (SQLite or in-memory)
- Claude generates Dockerfile, package.json, Express routes
- Build succeeds
- App deploys to `https://<app-name>.k8s-lab.dev`

### Test 2: React Frontend

Input: "I want to build a React dashboard with charts"

Expected:
- ChatGPT designs a React app
- Claude generates Dockerfile (nginx or serve), package.json, React components
- Build succeeds
- Frontend deploys

### Test 3: Full Stack App

Input: "I want to build a blogging platform with user authentication"

Expected:
- ChatGPT designs Express backend + React frontend (or monorepo)
- Claude generates code for both
- Build succeeds
- App deploys

## Future Improvements

### Enhancements to Add

1. **Error Handling**: Add If nodes after each critical step to catch failures
2. **Build Timeout**: Add max iterations to wait loop
3. **Cleanup**: Delete failed BuildKit Jobs
4. **Notifications**: Send Slack/email on success/failure
5. **Validation**: Check AI output format before writing files
6. **Rollback**: If build fails, remove uncommitted files
7. **Multi-language**: Support Python, Go, etc. (not just Node.js)

### Workflow 2: Webapp Update Automation

The next workflow to build is the webhook-triggered update automation:

- GitHub webhook on push events
- Parse conventional commit
- Query registry for current version
- Calculate semver bump
- Build new image
- Flux Image Automation updates manifests automatically

This workflow is simpler (no AI needed) and follows the same Kubernetes API pattern.

## Support

If you encounter issues:

1. Check n8n execution logs in the workflow UI
2. Check n8n pod logs: `kubectl -n automation logs -f deployment/n8n`
3. Check BuildKit job logs: `kubectl -n build-system logs job/<job-name>`
4. Review this documentation and troubleshooting section

## Architecture Decisions

### Why HTTP Request Instead of kubectl?

**Pros**:
- No need to install kubectl in n8n container
- Direct API access is more reliable
- Better error handling and response parsing
- Cleaner approach for automation

**Cons**:
- More verbose configuration
- Need to manage authentication manually
- Must handle YAML to JSON conversion for some operations

### Why Two-Stage AI (ChatGPT + Claude)?

**ChatGPT** is excellent at high-level architecture and design decisions
**Claude** excels at detailed code generation with proper structure

Using both:
- Separates concerns (design vs implementation)
- Reduces token usage (two smaller requests vs one huge request)
- Allows fine-tuning each stage independently

### Why File System Operations?

n8n needs a workspace to:
- Clone repositories
- Write generated files
- Run npm install
- Commit and push changes

The PVC provides persistent storage across workflow executions and pod restarts.

## Conclusion

This workflow automates the entire process of creating a new webapp from a simple text description. It combines:

- AI for design and code generation
- Git for version control
- BuildKit for container image building
- Kubernetes for orchestration
- Flux for GitOps deployment

The result: From idea to deployed webapp in ~5-10 minutes! üöÄ
